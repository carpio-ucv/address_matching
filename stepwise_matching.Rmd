---
title: "Stepwise data matching process"
output: html_document
---

## Summary

The Residents Matrix matching process consists of merging different data sets in order to 


1- Working Address and Post Code - (WAPC)
2- Troncade first 8 characters and Post Code - (T8PC) 
3- Troncade first 8 characters and Post Code, but eliminating the word FLAT - (T8_FPC)
4- Property and Premise number and Post Code - (PPNPC)
5- Working Address (Without Post Code) - (WAWPC)



## 1. Opening relevant R packages

```{r setup, include=TRUE, warning=FALSE, message=FALSE}

library("data.table")
library("dplyr")
library("reshape2")

rm(list = ls())

```


## 2. Upload raw data and define working data sets.

Data sets are defined as "a" and "b", where "a" will be the base data set, in other words, the file to which new variables will be added to. Usually, "a" will be the largest data set. In addition, one or more "filter" data frames may be defined as "f" (e.g. f1, f2) with the aim of filtering out irrelevant records from the original data sets (e.g. use blpu to filter out commercial properties).

### 2.1- Define working directory

```{r , include=TRUE, warning=FALSE, cache=TRUE, message=FALSE}

# Define working Directory
wd<- setwd("//dscs/cscom/Policy/Corp Information/Olypmic Hosts NKM (secure)/Community Mapping 2017/Juans_tests/2015")
wd
```


```{r , include=TRUE, warning=FALSE, cache=TRUE, message=FALSE}

# Upload data sets 
a<- fread("gz_tidy.csv") # Gazeteer tidy data
names(a)
nrow(a)
b<-fread("gp_tidy.csv") # GP tidy data 
names(b)
nrow(b)

####################

# ALGORITHM

## Steps order

step1<-2
step2<-4
step3<-5
step4<-6
step5<-3

steps<-(c(2,4,5,6,3))

## Words to identify variables containing Unique Identifiers, or Addresses
ui<-c("adr|UPRN|id|V1.x")

## Function

matching <- function (a,b) {
  
  adr<-names(a)[grep("adr",names(a))] # define the variable containing full address in dataset "a" for filterin purposes
  
  first_join<-merge(b,a,by.y=names(a)[step1], by.x=names(b)[step1], all.x = TRUE)
  unmatch_1<- first_join %>% filter(is.na(get(adr))) %>% select(1:length(names(b)))
  match_1<- first_join %>% filter(!is.na(get(adr))) %>%
    select(grep(ui,names(first_join))) 
  
  second_join<-merge(unmatch_1,a,by.y=names(a)[step2], by.x=names(b)[step2], all.x = TRUE)
  unmatch_2<- second_join %>% filter(is.na(get(adr))) %>% select(1:length(names(b)))
  match_2<- second_join %>% filter(!is.na(get(adr))) %>%
    select(grep(ui,names(second_join)))
  
  third_join<-merge(unmatch_2,a,by.y=names(a)[step3], by.x=names(b)[step3], all.x = TRUE)
  unmatch_3<- third_join %>% filter(is.na(get(adr))) %>% select(1:length(names(b)))
  match_3<- third_join %>% filter(!is.na(get(adr))) %>%
    select(grep(ui,names(third_join))) 

  fourth_join<-merge(unmatch_3,a,by.y=names(a)[step4], by.x=names(b)[step4], all.x = TRUE)
  unmatch_4<- fourth_join %>% filter(is.na(get(adr))) %>% select(1:length(names(b)))
  match_4<- fourth_join %>% filter(!is.na(get(adr))) %>%
    select(grep(ui,names(fourth_join)))
  
  fifth_join<-merge(unmatch_4,a,by.y=names(a)[step5], by.x=names(b)[step5], all.x = TRUE)
  unmatch_5<- fifth_join %>% filter(is.na(get(adr))) %>% select(1:length(names(b)))
  match_5<- fifth_join %>% filter(!is.na(get(adr))) %>%
    select(grep(ui,names(fifth_join))) 
  
  unmatch_final<- fifth_join %>% filter(is.na(get(adr))) %>%
    select(grep(ui,names(fifth_join)))
  

#Matching Summary Table:
  no.matches<-c((nrow(match_1)),(nrow(match_2)),(nrow(match_3)),
               (nrow(match_4)),(nrow(match_5)))
  no.unmatches<-c((nrow(unmatch_1)),(nrow(unmatch_2)),(nrow(unmatch_3)),
               (nrow(unmatch_4)),(nrow(unmatch_5)))
  df.process<-as.data.frame(cbind(names(a)[steps],no.matches,no.unmatches))
  print(df.process)
  
#Final df  
  tot.matches<-rbind(match_1, match_2, match_3, match_4, match_5, unmatch_final)
  
  matched.df <- tot.matches[order(tot.matches$V1.x),]
  matched.df <- matched.df[!duplicated(matched.df$V1.x),]

  print(nrow(df_grouped))
  
} 

matching(a,b)

###########


#bad<-rbind(x2f.1,x3f.1,x4f.1,x5f.1)
#nrow(bad)



```



## x- Managing Duplicated Records

### x.1- Keeping first line
```{r , include=TRUE, warning=FALSE, cache=TRUE, message=FALSE}



dup <- df_grouped[duplicated(tot.matches$V1.x),]

DUPLICATES
n_o <- data.frame(table(good$V1.x))
n_o[n_o$Freq > 1,]

good %>% filter(V1.x==95699)


```

### x.1- Manual process
```{r , include=TRUE, warning=FALSE, cache=TRUE, message=FALSE}

```


# Matching Accuracy Assessment

```{r , include=TRUE, warning=FALSE, cache=TRUE, message=FALSE}

```
